# Частота обновления спреда и логика выхода из сделки

## 1. КАК ЧАСТО ОБНОВЛЯЕТСЯ СПРЕД ПРИ ПОИСКЕ СИГНАЛОВ

### Механизм обновления

**WebSocket обновления:**
- **Binance**: Обновления приходят в реальном времени через WebSocket `bookTicker`
  - Частота: **~100-1000ms** (зависит от активности рынка)
  - При каждом обновлении вызывается `updateBinancePrice()` → `checkSpread()`

- **MEXC**: Обновления приходят в реальном времени через WebSocket `ticker`
  - Частота: **~100-1000ms** (зависит от активности рынка)
  - При каждом обновлении вызывается `updateMEXCPrice()` → `checkSpread()`

### Цепочка обновления спреда

```
1. Binance WebSocket получает обновление цены
   ↓
2. updateBinancePrice() вызывается
   ↓
3. checkSpread() вызывается (но может не вычислить спред, если нет MEXC цены)
   ↓
4. MEXC WebSocket получает обновление цены
   ↓
5. updateMEXCPrice() вызывается
   ↓
6. checkSpread() вызывается (теперь есть обе цены)
   ↓
7. Вычисляется спред (binanceMid, mexcMid, tickDifference, direction)
   ↓
8. onSpreadUpdate(spreadData) вызывается
   ↓
9. В server.ts: priceMonitor.onSpreadUpdate обрабатывает спред
   ↓
10. Если нет позиции → processSpread() (поиск сигнала)
    Если есть позиция → shouldClosePosition() (проверка закрытия)
```

### Частота обновления спреда

**Теоретически:**
- Спред обновляется при каждом обновлении цены на любой из бирж
- Если обе биржи обновляются одновременно → `checkSpread()` вызывается 2 раза
- Но спред вычисляется только когда есть обе цены (Binance И MEXC)

**Практически:**
- **Минимальная частота**: ~100ms (если обе биржи обновляются каждые 100ms)
- **Максимальная частота**: ~50ms (если обе биржи обновляются каждые 50ms)
- **Средняя частота**: ~100-200ms (типичная частота обновлений)

### Важно

**`checkSpread()` вызывается при каждом обновлении цены:**
- При обновлении Binance → `checkSpread()` (может не вычислить, если нет MEXC)
- При обновлении MEXC → `checkSpread()` (вычисляет спред, если есть Binance)

**Это означает:**
- Если Binance обновился, а MEXC еще нет → `checkSpread()` ничего не делает
- Когда MEXC обновится → `checkSpread()` вычисляет спред и отправляет событие
- Если обе биржи обновляются одновременно → `checkSpread()` вызывается 2 раза, но спред вычисляется только один раз (когда есть обе цены)

---

## 2. ЛОГИКА ВЫХОДА ИЗ СДЕЛКИ (shouldClosePosition)

### Приоритет проверок (от самого быстрого к самому медленному)

Функция `shouldClosePosition()` проверяет условия закрытия в следующем порядке:

---

### ✅ ПРОВЕРКА 1: "ПУТЬ ОТХОДА" - КРИТИЧЕСКИ ВАЖНО (проверяется ПЕРВЫМ)

**Цель:** Немедленно закрыться, если Binance развернулся против нас.

**Для LONG позиции:**
```typescript
// Мы купили по entryPrice, Binance должен быть ВЫШЕ
// Если Binance ask стал на 1+ тик НИЖЕ entryPrice → закрываемся НЕМЕДЛЕННО
const priceDiff = entryPrice - binanceAsk; // Положительное = Binance ниже
if (priceDiff >= tickSize) {
  return true; // Закрываемся НЕМЕДЛЕННО
}
```

**Для SHORT позиции:**
```typescript
// Мы продали по entryPrice, Binance должен быть НИЖЕ
// Если Binance bid стал на 1+ тик ВЫШЕ entryPrice → закрываемся НЕМЕДЛЕННО
const priceDiff = binanceBid - entryPrice; // Положительное = Binance выше
if (priceDiff >= tickSize) {
  return true; // Закрываемся НЕМЕДЛЕННО
}
```

**Пример:**
- LONG позиция, entryPrice = 5.920
- Binance ask = 5.919 (на 1 тик ниже)
- **Результат:** Закрываемся немедленно (защита от убытка)

---

### ✅ ПРОВЕРКА 2: "ПУТЬ ОТХОДА" - РАЗВОРОТ НАПРАВЛЕНИЯ

**Цель:** Закрыться, если направление спреда изменилось на противоположное.

```typescript
const originalDirection = this.currentSignal.spread.spread.direction; // 'long' или 'short'
const currentDirection = currentSpread.spread.direction; // 'long', 'short' или 'none'

// Если направление изменилось (было long → стало short, или наоборот)
if (originalDirection !== currentDirection && currentDirection !== 'none') {
  return true; // Закрываемся НЕМЕДЛЕННО
}
```

**Пример:**
- Открыли LONG (Binance был выше MEXC)
- Теперь Binance стал НИЖЕ MEXC (направление изменилось на SHORT)
- **Результат:** Закрываемся немедленно (ситуация развернулась)

---

### ✅ ПРОВЕРКА 3: "МАКСИМАЛЬНАЯ ПРИБЫЛЬ" - Для LONG позиции

**Цель:** Закрыться, когда цены сравнялись и можно закрыться в прибыль.

**Условия (все должны быть выполнены одновременно):**

1. **Цены сравнялись:**
   ```typescript
   const pricesConverged = binanceAsk <= mexcAsk;
   ```
   - Binance ask ≤ MEXC ask (цены на биржах сравнялись)

2. **Спред на MEXC сузился:**
   ```typescript
   const mexcSpread = mexcAsk - mexcBid;
   const mexcSpreadTicks = mexcSpread / tickSize;
   const mexcSpreadNarrowed = mexcSpreadTicks <= 1.0;
   ```
   - Спред на MEXC ≤ 1 тик (лимитки заполнились, рынок активен)

3. **Можно закрыться в прибыль или с минимальным убытком:**
   ```typescript
   const canCloseProfitably = mexcBid >= entryPrice - tickSize * 0.5;
   ```
   - MEXC bid ≥ entryPrice - 0.5 тика (можно закрыться без большого убытка)

**Пример:**
- LONG позиция, entryPrice = 5.920
- Binance ask = 5.920, MEXC ask = 5.920 (цены сравнялись) ✅
- MEXC спред = 0.5 тика (сузился) ✅
- MEXC bid = 5.9195 (≥ 5.920 - 0.0005 = 5.9195) ✅
- **Результат:** Закрываемся (все условия выполнены)

---

### ✅ ПРОВЕРКА 4: "МАКСИМАЛЬНАЯ ПРИБЫЛЬ" - Для SHORT позиции

**Цель:** Закрыться, когда цены сравнялись и можно закрыться в прибыль.

**Условия (все должны быть выполнены одновременно):**

1. **Цены сравнялись:**
   ```typescript
   const pricesConverged = binanceBid >= mexcBid;
   ```
   - Binance bid ≥ MEXC bid (цены на биржах сравнялись)

2. **Спред на MEXC сузился:**
   ```typescript
   const mexcSpread = mexcAsk - mexcBid;
   const mexcSpreadTicks = mexcSpread / tickSize;
   const mexcSpreadNarrowed = mexcSpreadTicks <= 1.0;
   ```
   - Спред на MEXC ≤ 1 тик (лимитки заполнились, рынок активен)

3. **Можно закрыться в прибыль или с минимальным убытком:**
   ```typescript
   const canCloseProfitably = mexcAsk <= entryPrice + tickSize * 0.5;
   ```
   - MEXC ask ≤ entryPrice + 0.5 тика (можно закрыться без большого убытка)

**Пример:**
- SHORT позиция, entryPrice = 5.920
- Binance bid = 5.920, MEXC bid = 5.920 (цены сравнялись) ✅
- MEXC спред = 0.5 тика (сузился) ✅
- MEXC ask = 5.9205 (≤ 5.920 + 0.0005 = 5.9205) ✅
- **Результат:** Закрываемся (все условия выполнены)

---

## 3. ПОРЯДОК ПРОВЕРОК (от быстрого к медленному)

```
shouldClosePosition() вызывается при каждом обновлении спреда (~100-200ms)

1. Быстрая проверка: Есть ли сигнал и спред? → Если нет, return false (<0.01ms)

2. КРИТИЧНО: "Путь отхода" - Binance развернулся против нас
   - LONG: entryPrice - binanceAsk >= tickSize → ЗАКРЫТЬ (<0.01ms)
   - SHORT: binanceBid - entryPrice >= tickSize → ЗАКРЫТЬ (<0.01ms)

3. КРИТИЧНО: "Путь отхода" - Направление изменилось
   - originalDirection !== currentDirection → ЗАКРЫТЬ (<0.01ms)

4. ОЖИДАНИЕ ПРИБЫЛИ: Для LONG позиции
   - pricesConverged (binanceAsk <= mexcAsk) ✅
   - mexcSpreadNarrowed (mexcSpread <= 1 тик) ✅
   - canCloseProfitably (mexcBid >= entryPrice - 0.5 тика) ✅
   → ЗАКРЫТЬ (~0.1ms)

5. ОЖИДАНИЕ ПРИБЫЛИ: Для SHORT позиции
   - pricesConverged (binanceBid >= mexcBid) ✅
   - mexcSpreadNarrowed (mexcSpread <= 1 тик) ✅
   - canCloseProfitably (mexcAsk <= entryPrice + 0.5 тика) ✅
   → ЗАКРЫТЬ (~0.1ms)

6. Если ни одно условие не выполнено → return false
```

---

## 4. ПРИМЕРЫ РАБОТЫ ЛОГИКИ

### Пример 1: "Путь отхода" - Binance развернулся

**Сценарий:**
- Открыли LONG по 5.920 (Binance был выше MEXC)
- Binance развернулся и стал ниже: Binance ask = 5.919

**Проверка:**
```
entryPrice = 5.920
binanceAsk = 5.919
priceDiff = 5.920 - 5.919 = 0.001 (1 тик)
priceDiff >= tickSize (0.001) → TRUE
```

**Результат:** ✅ Закрываемся НЕМЕДЛЕННО (защита от убытка)

---

### Пример 2: "Путь отхода" - Направление изменилось

**Сценарий:**
- Открыли LONG (originalDirection = 'long')
- Binance стал ниже MEXC (currentDirection = 'short')

**Проверка:**
```
originalDirection = 'long'
currentDirection = 'short'
originalDirection !== currentDirection → TRUE
```

**Результат:** ✅ Закрываемся НЕМЕДЛЕННО (ситуация развернулась)

---

### Пример 3: "Максимальная прибыль" - LONG позиция

**Сценарий:**
- Открыли LONG по 5.920
- Цены сравнялись: Binance ask = 5.920, MEXC ask = 5.920
- Спред на MEXC сузился: mexcSpread = 0.5 тика
- MEXC bid = 5.9195

**Проверка:**
```
1. pricesConverged = (5.920 <= 5.920) → TRUE ✅
2. mexcSpreadNarrowed = (0.5 <= 1.0) → TRUE ✅
3. canCloseProfitably = (5.9195 >= 5.920 - 0.0005) → TRUE ✅
```

**Результат:** ✅ Закрываемся (все условия выполнены, можно закрыться с минимальным убытком или в прибыль)

---

### Пример 4: "Максимальная прибыль" - SHORT позиция

**Сценарий:**
- Открыли SHORT по 5.920
- Цены сравнялись: Binance bid = 5.920, MEXC bid = 5.920
- Спред на MEXC сузился: mexcSpread = 0.5 тика
- MEXC ask = 5.9205

**Проверка:**
```
1. pricesConverged = (5.920 >= 5.920) → TRUE ✅
2. mexcSpreadNarrowed = (0.5 <= 1.0) → TRUE ✅
3. canCloseProfitably = (5.9205 <= 5.920 + 0.0005) → TRUE ✅
```

**Результат:** ✅ Закрываемся (все условия выполнены, можно закрыться с минимальным убытком или в прибыль)

---

## 5. ВАЖНЫЕ МОМЕНТЫ

### Частота проверки закрытия

- **`shouldClosePosition()` вызывается при каждом обновлении спреда**
- Частота: **~100-200ms** (как часто обновляется спред)
- Это означает, что мы проверяем условия закрытия **5-10 раз в секунду**

### Приоритет скорости

1. **"Путь отхода"** проверяется ПЕРВЫМ (самые быстрые проверки)
2. **"Максимальная прибыль"** проверяется ПОСЛЕ (более сложные вычисления)

### Логика "Максимальная прибыль"

**Почему нужны все 3 условия?**

1. **pricesConverged** - Цены на биржах сравнялись (арбитражная возможность исчерпана)
2. **mexcSpreadNarrowed** - Спред на MEXC сузился (лимитки заполнились, рынок активен)
3. **canCloseProfitably** - Можно закрыться без большого убытка (защита от убыточного закрытия)

**Если хотя бы одно условие не выполнено:**
- Позиция остается открытой
- Проверка повторяется при следующем обновлении спреда (~100-200ms)

---

## 6. ИТОГОВАЯ СХЕМА

```
WebSocket обновления (Binance/MEXC)
    ↓
checkSpread() (~100-200ms)
    ↓
onSpreadUpdate(spreadData)
    ↓
priceMonitor.onSpreadUpdate()
    ↓
┌─────────────────────────────────┐
│ Есть открытая позиция?          │
└─────────────────────────────────┘
    │                    │
   ДА                   НЕТ
    ↓                    ↓
shouldClosePosition()  processSpread()
    │                    │
    ├─ "Путь отхода"     ├─ Проверка условий
    │  (Binance развернулся) │  (tickDiff, direction)
    │                    │
    ├─ "Путь отхода"     ├─ Анализ стакана
    │  (Направление изменилось) │  (ликвидность, slippage)
    │                    │
    └─ "Максимальная прибыль"    │
       (Цены сравнялись +      │
        Спред сузился +        │
        Можно закрыться)       │
    │                    │
    ↓                    ↓
closePosition()    onSignal() → openPosition()
```

---

## 7. ВРЕМЯ РЕАКЦИИ

### Детект сигнала закрытия

- **"Путь отхода"**: <0.01ms (прямое сравнение цен)
- **"Максимальная прибыль"**: ~0.1ms (несколько вычислений)

### Время от детекта до закрытия

- **Детект сигнала**: <0.1ms
- **Вызов closePosition()**: <0.01ms
- **Закрытие позиции**: ~221ms (на сервере, пинг 10ms)

**Итого:** ~221ms от момента выполнения условий до фактического закрытия

---

## 8. ЗАЩИТА ОТ УБЫТКОВ

### "Путь отхода" - основная защита

- Срабатывает при развороте Binance против нас
- Закрывает позицию НЕМЕДЛЕННО (без ожидания)
- Защищает от больших убытков

### "Максимальная прибыль" - оптимизация

- Закрывает позицию, когда можно закрыться в прибыль или с минимальным убытком
- Ждет, пока все условия не будут выполнены
- Позволяет максимизировать прибыль

---

## ВЫВОДЫ

1. **Спред обновляется ~100-200ms** (при каждом обновлении цены на любой бирже)
2. **Условия закрытия проверяются 5-10 раз в секунду**
3. **"Путь отхода"** - самая быстрая проверка (<0.01ms), срабатывает первой
4. **"Максимальная прибыль"** - более сложная проверка (~0.1ms), срабатывает после "пути отхода"
5. **Время реакции**: ~221ms от детекта до закрытия (на сервере)

